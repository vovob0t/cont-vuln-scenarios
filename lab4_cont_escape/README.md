## Сценарий 4: Побег из контейнера  
**Уровень сложности:** продвинутый  
**Суть проблемы:** В самом сложном квесте рассматривается сценарий **container breakout** – выход из изолированного контейнера на узел хоста. Легенда: службы безопасности заметили странное поведение на сервере Docker: в логах обнаружены попытки доступа контейнера к системным файлам хоста. Мониторинг (например, Falco) сгенерировал оповещение о том, что процесс внутри контейнера пытался изменить файл `/etc/shadow`. Возникло подозрение, что один из контейнеров сумел прорваться через границы изоляции. Ваша задача – воспроизвести и исследовать этот «побег», понять, какие уязвимости конфигурации это позволили (например, запуск контейнера с чрезмерными привилегиями или монтирование сокета Docker), и внедрить механизмы защиты, чтобы такое не повторилось.

### Запуск
- Сборка и запуск
```sh
docker-compose up -d --build
```
- Войдите внутрь запущенного контейнера:
```
docker exec -it <container_id_or_name> sh
```

- Попробуйте с помощью Docker CLI из контейнера запустить новый контейнер, который, например, примонтирует корневой каталог хоста:
```sh
docker run --rm -v /:/host alpine:latest sh -c "echo 'Hacked!' > /host/tmp/pwned.txt"
```

- Проверьте на хосте наличие файла /tmp/pwned.txt – если он создан, значит атака удалась.

Разберём, что делает эта команда: она просит **хостовый Docker** (через /var/run/docker.sock) запустить новый контейнер из образа *alpine*, примонтировав весь корневой каталог хоста `/` внутрь контейнера по пути `/host`. Затем внутри нового контейнера выполняется командa, дописывающая строку в файл `/host/tmp/pwned.txt` (то есть в `/tmp` на хосте). После выполнения, этот временный контейнер завершается.  
Если команда прошла успешно, на **хостовой машине** (вне Docker) теперь появится файл `/tmp/pwned.txt` с соответствующим содержимым. Это доказательство того, что мы изнутри контейнера смогли записать файл на хосте, обходя изоляцию! По сути, мы запустили новый контейнер "от лица" хоста с привилегиями доступа к файлам.  
- Ещё более очевидный «побег»: вместо простого файла, можно запуском контейнера с `-v /:/host` открыть shell и получить полнофункциональный root-доступ к хосту. Например,  
 ```shell
 docker run -it -v /:/host --privileged alpine:latest chroot /host /bin/bash
 ```  
 Эта команда откроет shell с root-файловой системой хоста. Практически, вы теперь находитесь **внутри хостовой ОС** из контейнера.

### Фикс

Чтобы устранить эту уязвимость:

Не монтируйте Docker-сокет в контейнер, если в этом нет крайней необходимости.

Если Docker-инструмент всё-таки требуется (например, для CI/CD), применяйте специальные решения (например, Docker-in-Docker с отдельным демоном или безопасное API с ограниченными возможностями).

Пересоберите docker-compose без volume с Docker-сокетом:

```yml
version: "3.8"
services:
  escape:
    build: .
    # Удаляем монтирование Docker-сокета
    # volumes:
    #   - "/var/run/docker.sock:/var/run/docker.sock"
```
Пересоберите и запустите контейнер – теперь атакующий не сможет получить доступ к Docker-демону хоста.
