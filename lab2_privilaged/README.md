## Сценарий 2: Контейнер с привилегиями root и открытым портом  
**Уровень сложности:** начальный  
**Суть проблемы:** В этом квесте изучается опасность запуска контейнеров от имени суперпользователя (root) и неправильно экспонированных портов. Легенда: администратор заметил, что веб-сервис в контейнере работает с правами root, и к тому же в Docker Compose файл проброшен внутренний сервис на внешний порт, доступный всем. Такие настройки облегчают эксплуатацию уязвимостей: если злоумышленник получит доступ к приложению через открытый порт и скомпрометирует его, он сразу окажется в контейнере с правами root, что увеличивает ущерб и может привести к выходу на хост. Задача – выяснить, какие конфигурации в Dockerfile/Compose приводят к этим проблемам, и исправить их.

**Инструкции по запуску окружения:** Подготовлен Docker Compose с двумя сервисами: например, веб-приложение и база данных. В Dockerfile веб-приложения намеренно **не указан** пользователь (по умолчанию будет root), а в docker-compose.yml есть директива, открывающая порт во внешний мир. Шаги запуска:  
1. Перейдите в каталог сценария 2 и запустите окружение:  
   ```shell
   docker-compose up -d --build
   ```  
   Это развернёт контейнер веб-приложения (например, на основе образа Node/Python) и БД. В Compose-файле прописано что-то вроде:  
   ```yaml
   ports:
     - "0.0.0.0:8080:5000"
   ```  
2. Убедитесь, что приложение доступно через браузер или curl по адресу `http://localhost:8080`. Оно должно функционировать (например, отдавать простую страницу).  

###  **Ключевые шаги расследования:** Расследуем конфигурацию безопасности запущенных контейнеров.  
1. **Проверка пользователя внутри контейнера:** Выполните команду, чтобы узнать, под каким пользователем запущен процесс в контейнере:  
   ```shell
   docker exec -it <web_container> id
   ```  
   Также можно зайти в шелл: `docker exec -it <web_container> bash` и выполнить `whoami`. Ожидается, что вы увидите пользователя **root** (UID 0). Это сразу красный флаг: приложение запущено от имени администратора внутри контейнера. По принципу наименьших привилегий это неправильно – процессу веб-сервера не нужны привилегии суперпользователя.  
2. **Изучение Dockerfile:** Откройте Dockerfile веб-сервиса. В нём, скорее всего, **отсутствует директива USER**, поэтому Docker по умолчанию запускает процесс от root. Также проверьте, не выполняются ли там команды, требующие root (иногда разработчики оставляют `sudo` внутри контейнера, что лишнее и небезопасно). Обратите внимание на строки, которые могут указывать на работу с повышенными привилегиями.  
3. **Анализ открытых портов:** Изучите docker-compose.yml. Найдите секцию сервиса веб-приложения с `ports`. Здесь явным образом проброшен порт наружу. Вопросы для анализа: Действительно ли необходимо, чтобы этот порт был доступен извне? Например, если это БД или внутренний сервис, его не стоит публиковать на 0.0.0.0. Убедитесь, что даже база данных не имеет лишнего `ports` (в нашем сценарии мы могли специально открыть порт БД для демонстрации, хотя обычно БД должна быть доступна только другим контейнерам в сети).  
   - Попробуйте с хоста подключиться к сервисам на этих портах (через `curl` или соответствующий клиент для БД) – доступ возможен без авторизации? Если да, то злоумышленник теоретически тоже мог бы подключиться удалённо, если порт не закрыт файрволом.  
4. **Оценка рисков:** Представьте, что у веб-приложения есть уязвимость (SQL-инъекция, удалённое выполнение кода и т.д.), через которую атакующий получил доступ внутрь контейнера. Так как контейнер работает под root, злоумышленник теперь имеет права суперпользователя в контейнере. Это опасно, потому что он может:  
   - Модифицировать файлы приложения или системы в контейнере (например, встроить backdoor).  
   - Попытаться выйти из контейнера, эксплуатируя привилегии (например, известные уязвимости Docker/ядра, либо неправильные монтирования).  
   - Использовать открытый порт для дальнейшего распространения атаки или доступа к другим сервисам.  
   Этот шаг теоретический, но в реальных условиях подобная комбинация (root + открытый порт) очень рискованна.  


### **Способы устранения:** Исправим выявленные проблемы по отдельности:  
- **Запуск от непривилегированного пользователя:** В Dockerfile добавьте создание пользователя и переключение на него. Например:  
```Dockerfile
# Dockerfile (уязвимый вариант)
FROM python:3.9-slim
WORKDIR /app
COPY . .
RUN pip install flask \
  && adduser --disabled-password --gecos "" appuser \
  && chown -R appuser /app
# Здесь не указан пользователь – по умолчанию процесс работает от root
USER appuser
CMD ["python", "app/app.py"]
```

- **В docker-compose.yml ограничим привязку порта только к localhost.**
```yml
version: "3.8"
services:
  web:
    build: .
    # Привязываем порт только к 127.0.0.1, чтобы сервис был доступен только локально
    ports:
      - "127.0.0.1:8080:5000"
```
