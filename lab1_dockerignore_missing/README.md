
## Сценарий 1: Пропавший *.dockerignore*  
**Уровень сложности:** начальный  
**Суть проблемы:** Команда разработчиков заметила, что Docker-образ их приложения имеет подозрительно большой размер и, возможно, содержит лишние файлы. Появились опасения, что внутрь образа попали конфиденциальные данные (например, исходный код, пароли или ключи), которых там быть не должно. Легенда: приложение развёрнуто в контейнере Docker, но кто-то забыл создать файл *.dockerignore*, из-за чего в образ скопировались все файлы из рабочей директории. В результате секреты и лишние данные «утекли» в образ. Задача – исследовать содержимое контейнера, найти посторонние/чувствительные файлы и исправить Dockerfile конфигурацию.


**Инструкции по запуску окружения:** Для этого сценария подготовлен Dockerfile и Docker Compose файл. Убедитесь, что Docker установлен локально. Шаги для запуска:  
1. Склонируйте проект квеста (или перейдите в каталог сценария 1). В директории находится Dockerfile приложения и необходимые файлы.  
2. **Запустите сборку и контейнер:** выполните команду:  
   ```shell
   docker-compose up -d
   ```  
   Это соберёт Docker-образ на основе Dockerfile (без *.dockerignore*) и запустит контейнер. Контейнер должен подняться и работать (например, веб-приложение на порту 5000).  

**Ключевые шаги расследования:** Теперь исследуйте ситуацию и выявите уязвимости.  
1. **Исследуйте образ и контейнер:** Откройте терминал внутри работающего контейнера, чтобы просмотреть его файловую систему. Например:  
   ```shell
   docker exec -it <имя_контейнера> sh
   ```  
   Проверьте, нет ли внутри контейнера файлов, которых не ожидается в рабочей среде. Обратите внимание на возможные конфиденциальные файлы: например, файлы исходного кода (*.java, *.py, *.js и др.*), файлы настроек с паролями (*.env, config.yaml*), папки вроде *.git* (репозиторий) и т.д. Если такие файлы присутствуют внутри контейнера, это свидетельствует о том, что при сборке образа не были исключены лишние ресурсы.  
2. **Анализ Dockerfile:** Откройте Dockerfile проекта. Обычно в Dockerfile копируют файлы командой `COPY . /app` или подобной. Если не используется *.dockerignore*, то указанная команда скопирует **всё** из контекста сборки. Убедитесь, что действительно все файлы приложения попали в образ. В нашем сценарии в образ, например, могли попасть файлы с секретами (скажем, *.env* с паролями к базе данных) или папка с исходниками/исследовательскими данными, не нужными для запуска.  
3. **Используйте инструментарий:** Попробуйте запустить **сканер уязвимостей Trivy** на полученном образе. Команда:  
   ```shell
   trivy image <имя_образа>
   ```  
   Trivy может обнаружить **hardcoded secrets** (жёстко прописанные секреты) и уязвимости в слоях образа. Если в образ включён, например, файл с паролями или ключами, Trivy отметит это как проблему. Также он покажет известные CVE для базового образа и зависимостей. Это поможет подтвердить нахождение секретов и лишних файлов внутри.  
4. **Выявление проблемы:** Сопоставив результаты, вы, вероятно, обнаружите, что в образе присутствуют лишние файлы и секретные данные, которых можно было избежать. Например, найдётся API-ключ или пароль, который **не должен быть упакован** в контейнер. Это и есть уязвимость: любой, кто получит образ (через реестр Docker или доступ к системе), сможет извлечь эти секреты.  

## Solution
**Способы устранения:** Найдя проблему, необходимо скорректировать процесс сборки образа и конфигурацию:  
- **Создайте *.dockerignore*:** 
```
.env
.git
```
- **Избирательное копирование:** Как дополнительная мера, можно настроить Dockerfile так, чтобы копировать только необходимый код. Например, вместо `COPY . /app` использовать более гранулярные COPY для конкретных директорий или воспользоваться multi-stage билдом, где в финальный образ копируется только артефакт приложения (без исходников и лишнего).  
- **Удаление секретов из репозитория:** Убедитесь, что конфиденциальные данные **вовсе не хранятся** в одном каталоге с Dockerfile. Например, секреты должны браться из переменных окружения или секретных хранилищ, а не из файлов, попадающих в образ. В идеале, использовать Docker Secrets или передавать секреты при деплое, а не пекать их в образ.  
